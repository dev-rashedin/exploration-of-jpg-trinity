## 4. Python Basics

Python is simple, but powerful. This section explains its core building blocks in beginner‑friendly language with examples.

## 4.1 Variables and Data Types

A **variable** is a container that stores a value.  
Think of it like a labeled box where you keep information.

### Key Points

- Variables store data such as text, numbers, true/false values, lists, etc.
- Variables are **case‑sensitive** (`name` and `Name` are different).
- Python uses **dynamic typing**, meaning you don’t have to declare a type.

### Example

```python
name = "Alice"       # string
age = 25             # integer
height = 5.7         # float
is_student = True    # boolean
```

## Typecasting

**Typecasting** means converting one data type into another.

### Built‑in Functions

- `str()` → convert to string
- `int()` → convert to integer
- `float()` → convert to floating number
- `bool()` → convert to boolean

### Example

```python
age = "25"
age_number = int(age)   # "25" → 25 (integer)

print(type(age_number))
```

## input()

`input()` allows the user to enter data from the keyboard.

- Always returns data as a **string**.
- Convert it using typecasting if needed.

### Example

```python
name = input("Enter your name: ")
age = int(input("Enter your age: "))  # convert to integer

print("Hello,", name)
print("You are", age, "years old")
```

## 4.2 Operators

Operators perform actions on values.

### Arithmetic Operators

| Operator | Meaning  | Example      |
| -------- | -------- | ------------ |
| +        | Add      | 3 + 2        |
| -        | Subtract | 5 - 1        |
| \*       | Multiply | 2 \* 4       |
| /        | Divide   | 9 / 2        |
| %        | Modulus  | 10 % 3 → 1   |
| \*\*     | Power    | 2 \*\* 3 → 8 |

### Built in math functions

```python
x = 3.14
y = -4
z = 5

- result = round(x)

- result = abs(y)

- result = pow(4, 3)

- result = max(x, y, z)

result = min(x, y, z)

print(result)
```

### Math modules

```python
import math

print(math.pi)
print(math.e)

result = math.sqrt(16)

result = math.ceil(2.1)

result = math.floor(2.9)

print(result)
```

## if Statement

- Do some code only if some condition is True
- Else do something else

```python
age = int(input('Enter your age:'))

if age >= 100:
    print('You are too old to open an account')
elif age >= 18:
    print('Your are eligible to open an account')
elif age < 0:
    print("You haven't been born yet")

else:
    print('You are not eligible to open an account')
```

## match case statement
 - An alternative to using many 'elif' statements
 - Execute some code if a value matches a 'case'
 - Benefits: cleaner and syntax is more readable

```python
def is_weekend(day):
    match day:
        case "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday":
            return False
        case "Saturday" | "Sunday":
            return True
        case _:
            return False

print(is_weekend("Sunday"))
```


### Comparison Operators

Used to compare values (returns True or False):

`==`, `!=`, `<`, `>`, `<=`, `>=`

### Logical Operators

- evaluate multiple conditions (or, and, not)
  - or = at least one condition must be true
  - and = all conditions must be true
  - not = reverse the condition (not False, not True)

```python
temp = 15
is_sunny = False

if temp >= 28 or is_sunny:
  print('It is hot outside')
elif temp <= 15 and not is_sunny:
  print('It is a cool day')
  print('It is cloudy')
elif temp <= 0 and not is_sunny:
  print('It is freezing outside')
  print('It is cloudy')
elif 28 > temp > 0 and is_sunny:
  print('It is warm outside')
  print('It is sunny')
```

# conditional expression

- A one-line shortcut for the if-else statement (ternary operator)
- Print or assign one of two values based on a condition
- X if condition else Y

```python
num = 5
a = 6
b = 7

print('Positive' if num > 0 else 'Negative')

print('Positive' if num > 0 else 'Negative')


result = 'Even' if num % 2 == 0 else "Odd"

max_num = a if a > b else b

print(f"The maximum number is {max_num}")

min_num = a if a < b else b

print(f"The minimum number is {min_num}")

```

## String method

```python
name = "rashedin islam"

len(name) # Returns the length of the string

name.upper() # Returns the string in upper case

name.lower() # Returns the string in lower case

name.find('s') # Returns the index of the specified string. It will give the first index. if it is not found, it returns -1

name.rfind('a') # Returns the index of the specified string. It will give the last index. if it is not found, it returns -1

name.capitalize()  # Returns the string in title case (the first letter of the string will be in upper case )

name.title()  # Returns the string in title case (the first letter of each word will be in upper case )

name.isdigit()  # Returns True if the string contains only digits

name.isalpha()  # Returns True if the string contains only alphabetic characters

name.isnumeric()  # Returns True if the string contains only digits

name.count("a") # Returns the number of times a specified value occurs in a string

number.replace("", "-") # Replaces all occurrences of a specified value with another value
```

## Indexing in String

- Accessing element of a sequence using [] (indexing operator)
- [start: end : stop]

```python
credit_number = "1234-45445-43213-1341"

credit_number[0] # gives the first character in the string

credit_number[0: 4] # gives the first 4 characters in the string

credit_number[: 4] # gives the first 4 characters in the string

credit_number[4: 8] # gives the next 4 characters in the credit_number[5:] # gives all characters after the 5th character in the string

credit_number[-3] # gives the number form the end

credit_number[0 : 4 : 2] # gives the first 4 characters in the string with a step of 2

credit_number[::2] # gives all characters in the string with a step of 2
```

## Example Program Using Everything

```python
name = input("Your name: ")

age = int(input("Your age: "))

if age >= 18 and age <= 60:
    print("Hello", name, "- You are an adult.")
elif age > 60:
    print("Hello", name, "- You are a senior.")
else:
    print("Hello", name, "- You are a minor.")

print("Age squared:", age ** 2)
print("Is your age even?", age % 2 == 0)
```

### 4.3 Loops

```python

# while loop
# execute some code WHILE some condition remain true

name = input('Enter your name: ')

while  name == '':
  print('You did not enter your name')
  name = input('Enter your name: ')
else:
  print(f'Hello {name}')

# For loops
# execute a block of code a fixed number of times.
# You can iterate over a range, string, sequence, etc


for x in (range(1, 11)):
  print(x)


for x in reversed(range(1, 11)):
  print(x)


for x in range(1, 11, 2):
  print(x)

# the first parameter in range is the start value
# the second parameter is the end value
# the third parameter is the step value

# For loop is count based (when we know how many time it's going to run)

# While loop is condition based (when we don't know how many time it's going to run)

# nested loop
# a loop within another loop (outer, inner)
# outer loop:
#   inner loop:


for x in range(3):
    for y in range(1, 10):
        print(y, end="")
    print()

```

# Python Collections

- Collection in python is a single "variable" used to store multiple values
- Python has three main collection types used to store multiple values.

TYPE OVERVIEW

List [] → Ordered, changeable, allows duplicates  
Set {} → Unordered and immutable, unique items only, add/remove allowed  
Tuple () → Ordered, unchangeable, allows duplicates, faster than lists

WHEN TO USE WHAT

List → You need order + frequent updates  
Set → You need uniqueness + fast membership check  
Tuple → You need safe, read-only, faster data storage

```python
# -----------------------
# Common Methods (all 3)
# -----------------------
fruits_list = ['apple', 'banana', 'orange']
fruits_set = {'apple', 'banana', 'orange'}
fruits_tuple = ('apple', 'banana', 'orange')

# Membership check → all support
'apple' in fruits_list   # True
'apple' in fruits_set    # True
'apple' in fruits_tuple  # True

# Length → all support
len(fruits_list)         # 3
len(fruits_set)          # 3
len(fruits_tuple)        # 3

# Looping → all support
for fruit in fruits_list:
    print(fruit)
for fruit in fruits_set:
    print(fruit)
for fruit in fruits_tuple:
    print(fruit)

# -----------------------
# Methods modifying collection
# -----------------------

# Add item → only list and set
fruits_list.append('mango')  # add to end of list
fruits_set.add('mango')      # add to set
# append and add methods are not supported in tuples because they are immutable (unchangeable)

# Remove item → only list and set
fruits_list.remove('banana') # remove by value
fruits_set.remove('banana')  # remove by value
# remove is not supported in tuples because they are immutable (unchangeable)

# Clear all → only list and set
fruits_list.clear()          # empties the list
fruits_set.clear()           # empties the set

# clear methods is not supported in tuples because they are immutable (unchangeable)

# -----------------------
# List-specific methods
# -----------------------
fruits_list.insert(1, 'kiwi')  # insert at specific index
fruits_list.sort()              # sort alphabetically
fruits_list.reverse()           # reverse order
fruits_list[0]                  # access by index

# Not supported in set or tuple, because:
# - insert → sets are unordered, tuples are immutable
# - sort → sets are unordered, tuples are immutable
# - reverse → sets are unordered, tuples are immutable
# - index access → sets are unordered, tuples do not change but can access by index

# -----------------------
# Set-specific methods
# -----------------------
fruits_set.pop()  # remove random item (since set is unordered, no index)
# Auto-uniqueness → {'apple', 'apple'} becomes {'apple'} (cannot have duplicates)
# Not supported in list: pop() removes last item, not random
# Not supported in tuple: tuples are immutable, cannot remove items

# -----------------------
# Tuple-specific methods
# -----------------------

fruits_tuple.count('apple')    # count occurrences
fruits_tuple.index('banana')   # find position of item
# Not supported in list/set in same way:
# - list.count/index exist but tuples are immutable so safe for read-only
# - set has no order so index/count by position is meaningless

```

### 4.5 Dictionaries (dict) — Key-Value Data Structure

A dictionary is a collection of **key : value** pairs.

Think of it like:
- a real dictionary → *word : meaning*
- a phone book → *name : number*

KEY PROPERTIES

• Written using `{}`  
• Keys must be **unique**  
• Ordered (Python 3.7+)  
• Changeable (mutable)  
• Fast lookup by key  

```python

# CREATING A DICTIONARY

capitals = {
    "Bangladesh": "Dhaka",
    "Sweden": "Stockholm",
    "Finland": "Helsinki",
    "Iceland": "Reykjavik",
    "Germany": "Berlin",
    "UK": "London",
    "USA": "Washington DC",
    "Japan": "Tokyo"
}


# ACCESSING VALUES

capitals["Bangladesh"]      
# Direct access → returns "Dhaka"
# ❌ Error if key does not exist

capitals.get("Bangladesh")  
# Safe access → returns "Dhaka"

capitals.get("China")       
# Returns None instead of error (recommended)


# GETTING KEYS, VALUES, ITEMS

capitals.keys()   
# Returns all keys

capitals.values() 
# Returns all values

capitals.items()  
# Returns (key, value) pairs


# ADDING OR UPDATING ITEMS


capitals["Australia"] = "Canberra"
# Adds new key-value pair

capitals["USA"] = "Washington D.C."
# Updates existing value

capitals.update({"France": "Paris"})
# Add or update using update()


# REMOVING ITEMS

capitals.pop("France")
# Removes specific key

capitals.popitem()
# Removes the LAST inserted item (because dict is ordered)

capitals.clear()
# Removes all items


# CHECKING MEMBERSHIP

"Japan" in capitals
# True → checks keys only

"Tokyo" in capitals
# False → values are NOT checked

# LOOPING THROUGH DICTIONARY

for key, value in capitals.items():
    print(key, "→", value)

Explanation:
- `.items()` gives both key and value
- Most common way to loop dictionaries

```

When to use dictionary

 - You need fast lookup  
 - You need meaningful keys  
 - You want structured data  

Example use cases:
- user_id → user_data
- country → capital
- config_name → config_value

One line summary
 - Dictionary = ordered, mutable key-value storage with fast access

---

## 4.6 Functions

 - A function is a **block of reusable code**.  
 - You define it once, then **call (invoke)** it whenever needed using `()`.

### Functions help you:
 - avoid repeating code
 - make programs readable
 - organize logic into small pieces


### BASIC FUNCTION (NO ARGUMENT)

```python
def happy_birthday():
    print("Happy birthday to you")
    print("Many happy returns of the day")
    print("Happy birthday to you")

happy_birthday()  # calling the function
```

Explanation:
- `def` → keyword to define a function
- `happy_birthday` → function name
- `()` → required to call the function
- Code runs only when the function is called

FUNCTION WITH ARGUMENTS


```python
def happy_birthday(name, age):
    print(f"Happy birthday to {name}")
    print(f"You are {age} years old")
    print(f"Happy birthday to you {name}")

happy_birthday("Ru", 30)
```

Explanation:
- `name` and `age` are parameters
- `"Ru"` and `30` are arguments
- Order matters here (positional arguments)

--------------------------------------------------
FUNCTION WITH RETURN VALUE
--------------------------------------------------

```python
# return ends the function and sends data back

def create_name(first, last):
    first = first.capitalize()
    last = last.capitalize()
    return f"{first} {last}"

full_name = create_name("rashedin", "islam")
print(full_name)
```

Explanation:
- `return` sends a value back to the caller
- Code after `return` does NOT run
- Returned value can be stored in a variable

--------------------------------------------------
DEFAULT ARGUMENTS
--------------------------------------------------

```python
# Default arguments are used when value is not provided

def net_price(list_price, discount=0, tax=0.05):
    return list_price * (1 - discount) * (1 + tax)

print(net_price(100))        # uses default discount & tax
print(net_price(100, 0.2))   # overrides discount
```

Explanation:
- Default values make functions flexible
- Default parameters must come AFTER positional ones

--------------------------------------------------
POSITIONAL vs KEYWORD ARGUMENTS
--------------------------------------------------

```python
# Keyword arguments improve readability
# Order does NOT matter when using keywords

def get_phone(cc, area, first, last):
    return f"{cc}-{area}-{first}-{last}"

phone = get_phone(cc=1, area=123, first=456, last=789)
print(phone)
```

Explanation:
- Each argument is labeled
- Safer and clearer than positional arguments
- Common in real-world code

--------------------------------------------------
ARGUMENT ORDER RULE (VERY IMPORTANT)
--------------------------------------------------

Python follows this strict order:
1. Positional arguments
2. Default arguments
3. Keyword arguments
4. Arbitrary arguments

Breaking this order causes errors.

--------------------------------------------------
ARBITRARY ARGUMENTS (*args)
--------------------------------------------------

```python
# *args allows unlimited positional arguments
# Stored as a tuple

def add_numbers(*args):
    total = 0
    for num in args:
        total += num
    return total

print(add_numbers(1, 2, 3, 4))
```

Explanation:
- Use when you don't know how many values will be passed
- `args` is just a name, `*` is what matters

--------------------------------------------------
ARBITRARY KEYWORD ARGUMENTS (**kwargs)
--------------------------------------------------

```python
# **kwargs allows unlimited keyword arguments
# Stored as a dictionary

def print_address(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_address(
    street="Terminal Road",
    city="Dhaka",
    country="Bangladesh"
)
```

Explanation:
- Useful for structured data
- Keys are strings, values can be anything

--------------------------------------------------
COMBINING *args AND **kwargs
--------------------------------------------------

```python
def shipping_label(*args, **kwargs):
    for arg in args:
        print(arg, end=" ")
    print()

    print(f"Street: {kwargs.get('street')}")
    print(f"City: {kwargs.get('city')}")
    print(f"Zip: {kwargs.get('zip')}")
    print(f"Country: {kwargs.get('country')}")

shipping_label(
    "Dr.", "Rashedin", "Islam",
    street="Terminal Road",
    city="Dhaka",
    zip="1000",
    country="Bangladesh"
)
```

Explanation:
- `*args` → positional extras
- `**kwargs` → keyword extras
- Common in frameworks (Django, Flask, FastAPI)

--------------------------------------------------
ONE-LINE SUMMARY
--------------------------------------------------

 - Function = reusable logic  
 - Arguments = input  
 - Return = output  
 - *args = many positional inputs  
 - **kwargs = many named inputs  
## Modules — Reusing Code in Python

A **module** is simply a **Python file** that contains variables, functions, or classes  
that you want to reuse in another program.

Think of a module like:
- a **toolbox**
- a **helper file**
- a **separate feature file**


Modules help you:

- break large programs into smaller files  
- reuse code instead of rewriting it  
- keep code clean and organized  
- use Python’s built-in features  

Importing Modules

```python
# Import a built-in module
import math

math.sqrt(16)        # 4.0
math.pi              # 3.141592653589793

# Import with alias

import math as m

m.sqrt(25)           # 5.0
m.pi                 # same value, shorter name
```


### Import Specific Items

```python
# Import only what you need
from math import pi, sqrt

sqrt(36)             # 6.0
pi                   # directly accessible

# Note:
# After using "from module import x"
# you DON'T need module name anymore
```

Crating Your Own Module

```python
# File: module_example.py
def square(num):
    return num * num

## USING YOUR OWN MODULE

import module_example

result = module_example.square(3)
print(result)        # 9

Explanation:
- Python looks for module_example.py in the same folder
- The file name becomes the module name
```


## FINDING AVAILABLE MODULES


help("modules")
# Shows all installed and built-in modules


## COMMON BUILT-IN MODULES

import math        # math operations
import random      # random numbers
import datetime    # date & time
import os          # operating system tasks
import sys         # system-level operations
import time        # delays & timers


## WHEN TO USE MODULES


- Code grows beyond one file  
- Logic is reused in multiple places  
- You want cleaner project structure  


## ONE-LINE SUMMARY


Module = reusable Python file imported using `import`


## Variable Scope — Where a Variable Can Be Used

**Variable scope** defines **where a variable is visible and accessible** in your program.

Python follows a strict scope resolution order called **LEGB**:

L → Local  
E → Enclosed  
G → Global  
B → Built-in  

Python searches for variables in this exact order.


## LOCAL SCOPE


### Variables created inside a function
### Only accessible inside that function

def func1():
    x = 1          # local variable
    print(x)

def func2():
    x = 2          # different local variable
    print(x)

func1()  # 1
func2()  # 2

Explanation:
- Each function has its own local scope
- Same variable name does NOT conflict


## ENCLOSED SCOPE

### Variable in an outer function
### Accessible inside inner (nested) functions

def outer():
    x = 1          # enclosed variable

    def inner():
        print(x)   # can access enclosing scope

    inner()

outer()

Explanation:
- Inner function can read variables from outer function
- This is called **closure**


## GLOBAL SCOPE

### Variable defined outside all functions
### Accessible everywhere (read-only by default)

x = 3              # global variable

def func1():
    print(x)

def func2():
    print(x)

func1()  # 3
func2()  # 3

Explanation:
- Global variables can be read inside functions
- Modifying them requires `global` keyword


## BUILT-IN SCOPE

### Built-in variables and functions
### Always available in Python

from math import e

def func1():
    print(e)       # built-in constant

func1()

Examples of built-in names:
- len()
- print()
- range()
- True / False


## LEGB RULE SUMMARY

When Python sees a variable, it searches:

1. Local scope
2. Enclosed scope
3. Global scope
4. Built-in scope


## COMMON BEGINNER MISTAKE

### Trying to modify global variable without keyword

count = 0

def increase():
    # count += 1   ❌ Error
    pass

# Correct way
def increase():
    global count
    count += 1


## ONE-LINE SUMMARY

Scope controls where variables live and who can access them
